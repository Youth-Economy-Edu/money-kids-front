---
description:
globs:
alwaysApply: false
---
# 프론트엔드 결합도 규칙

## 개요
이 규칙은 코드베이스의 서로 다른 부분 간의 의존성을 최소화하는 원칙을 정의합니다.

## 추상화와 결합도 균형 (조기 추상화 피하기)

**규칙:** 사용 사례가 달라질 수 있는 경우 중복을 조기 추상화하지 말고, 낮은 결합도를 선호하세요.

**이유:**
- 잠재적으로 달라질 수 있는 로직을 하나의 추상화로 강제하는 것을 피함
- 미래의 요구사항이 불확실할 때 일부 중복을 허용하면 결합도가 낮아지고 유지보수성이 향상될 수 있음

#### 가이드라인:
추상화하기 전에 로직이 정말로 동일하고 모든 사용 사례에서 동일하게 유지될 가능성이 높은지 고려하세요. 분기가 가능한 경우(예: 다른 페이지가 공유 훅인 `useOpenMaintenanceBottomSheet`에서 약간 다른 동작이 필요한 경우), 초기에 로직을 분리하여 유지(중복 허용)하면 더 유지보수 가능하고 결합도가 낮은 코드가 될 수 있습니다. 팀과 트레이드오프를 논의하세요.

## 상태 관리 범위 지정 (과도하게 광범위한 훅 피하기)

**규칙:** 광범위한 상태 관리를 더 작고 집중된 훅/컨텍스트로 분해합니다.

**이유:**
- 컴포넌트가 필요한 상태 조각에만 의존하도록 하여 결합도 감소
- 관련 없는 상태 변경으로 인한 불필요한 리렌더링 방지를 통한 성능 향상

#### 권장 패턴:
```typescript
// cardId 쿼리 파라미터 전용 훅
import { useQueryParam, NumberParam } from "use-query-params";
import { useCallback } from "react";

export function useCardIdQueryParam() {
  const [cardIdParam, setCardIdParam] = useQueryParam("cardId", NumberParam);

  const setCardId = useCallback(
    (newCardId: number | undefined) => {
      setCardIdParam(newCardId, "replaceIn");
    },
    [setCardIdParam]
  );

  return [cardIdParam ?? undefined, setCardId] as const;
}

// 날짜 범위 등에 대한 별도 훅
// export function useDateRangeQueryParam() { /* ... */ }
```

이제 컴포넌트는 `cardId`가 필요한 경우에만 `useCardIdQueryParam`을 가져와 사용하므로 날짜 범위 상태 등과 분리됩니다.

## Props Drilling 제거를 위한 컴포지션 사용

**규칙:** Props Drilling 대신 컴포넌트 컴포지션을 사용합니다.

**이유:**
- 불필요한 중간 의존성을 제거하여 결합도를 크게 감소
- 더 평평한 컴포넌트 트리에서 리팩토링을 쉽게 하고 데이터 흐름을 명확히 함

#### 권장 패턴:
```tsx
import React, { useState } from "react";

// Modal, Input, Button, ItemEditList 컴포넌트가 존재한다고 가정

function ItemEditModal({ open, items, recommendedItems, onConfirm, onClose }) {
  const [keyword, setKeyword] = useState("");

  // Modal 내에서 직접 children을 렌더링하고 필요한 곳에만 props 전달
  return (
    <Modal open={open} onClose={onClose}>
      {/* Input과 Button을 직접 렌더링 */}
      <div style={{ display: "flex", justifyContent: "space-between", marginBottom: "1rem" }}>
        <Input
          value={keyword}
          onChange={(e) => setKeyword(e.target.value)} // 여기서 상태 관리
          placeholder="항목 검색..."
        />
        <Button onClick={onClose}>닫기</Button>
      </div>
      {/* ItemEditList를 직접 렌더링하고 필요한 props 전달 */}
      <ItemEditList
        keyword={keyword} // 직접 전달
        items={items} // 직접 전달
        recommendedItems={recommendedItems} // 직접 전달
        onConfirm={onConfirm} // 직접 전달
      />
    </Modal>
  );
}

// 중간 ItemEditBody 컴포넌트가 제거되어 결합도가 감소됨
```

## 컴포넌트 간 통신 최소화

**규칙:** 컴포넌트 간 직접적인 통신을 최소화하고 이벤트 기반 통신을 선호합니다.

**이유:**
- 컴포넌트 간 직접적인 의존성 감소
- 더 유연하고 테스트 가능한 구조 생성

#### 권장 패턴:
```typescript
// 이벤트 버스 또는 컨텍스트를 통한 통신
const EventBus = {
  listeners: new Map(),
  
  subscribe(event: string, callback: Function) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event).add(callback);
  },
  
  unsubscribe(event: string, callback: Function) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).delete(callback);
    }
  },
  
  emit(event: string, data?: any) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).forEach(callback => callback(data));
    }
  }
};

// 사용 예시
function ComponentA() {
  useEffect(() => {
    const handleDataUpdate = (data) => {
      // 데이터 업데이트 처리
    };
    EventBus.subscribe('dataUpdated', handleDataUpdate);
    return () => EventBus.unsubscribe('dataUpdated', handleDataUpdate);
  }, []);
}

function ComponentB() {
  const handleClick = () => {
    EventBus.emit('dataUpdated', { newData: 'value' });
  };
}
```

## 의존성 주입 활용

**규칙:** 하드코딩된 의존성 대신 의존성 주입을 사용합니다.

**이유:**
- 컴포넌트와 서비스 간의 결합도 감소
- 테스트 용이성 향상
- 유연한 구현 교체 가능

#### 권장 패턴:
```typescript
// 서비스 인터페이스 정의
interface DataService {
  fetchData(): Promise<any>;
  updateData(data: any): Promise<void>;
}

// 실제 구현
class ApiDataService implements DataService {
  async fetchData() {
    // API 호출 구현
  }
  
  async updateData(data: any) {
    // API 업데이트 구현
  }
}

// 컴포넌트에서 사용
function DataComponent({ dataService }: { dataService: DataService }) {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    dataService.fetchData().then(setData);
  }, [dataService]);
  
  return (
    // 데이터 표시
  );
}

// 사용 예시
function App() {
  const dataService = new ApiDataService();
  return <DataComponent dataService={dataService} />;
}
```
